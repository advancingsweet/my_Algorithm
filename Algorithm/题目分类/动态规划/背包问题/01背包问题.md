# 动态规划的核心思想：

根据之前已有的状态下的计算结果，计算出下一个状态的结果

 - 解释：对于0-1背包：

   - 相同体积下，所可以选择数量最多，则总价值越大（对于二维数组表的位置在同一列的最下方）

   - 相同选择下，体积越大则所总价值越大（对应于二维数组表的位置在同一行的最右边）

   - **所以为什么可以有上一个状态（对应在第i-1行的最左边和最右边两个位置）计算出下一个状态，因为上一个状态是同条件下最优解！！！**

     

# 01背包问题

[大佬详解！！！（一维变换讲得非常非常好！！！)](https://blog.csdn.net/qq_52416556/article/details/124486448?spm=1001.2014.3001.5501)

## 问题引入：

<img src="C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230313000835794.png" alt="image-20230313000835794" style="zoom:50%;" />

## 边界

<img src="C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230313002836747.png" alt="image-20230313002836747" style="zoom:50%;" />

边界理解：此边界并非作为结束条件的边界，而是防止被无限套娃，因为下一个状态的结果由前一个状态得出，且前一个状态又是由前前一个状态得出，所以，在最前面必须得有一个边界（即进行初始化），防止无限套娃。所以边界是：dp[ 0 ][ v ] = 0; (即在0个物品选择下，任何体积组合的情况其总价值均为0)

****************



## 解释

细分为三种情况：
①当前物品的体积v[i]大于背包总容量j时，那么就取只放前i-1个物品，总体积小于j的方案就行；
②当前物品的体积v[i]等于背包总容量j时，那么此时j - v[i] = 0，即f[ i - 1，j - v[i] ] + w[i] = f[i-1, 0] + w[i] = 0 + w[i] = w[i]，所以f[i,j] = max(f[i-1,j] , w[i])，此时二者选最大值的方案即可
③当前物品的体积v[i]小于背包总容量j时，此时j - v[i] > 0 ，也就是说背包用来放当前物品i后还有剩余的体积j - v[i] ，那么先放入当前物品i，再选择前i-1个物品且总体积小于等于j - v[i]的方案，所得的价值就是f[i - 1,j - v[i]] + w[i]，再把此价值与f[i - 1,j]取max即可

*******************

# 个人感悟

## 二维

将情况分成两种：

1. ​	当前背包的总体积小于第i件物品的体积 ，那么第i件物品不选。则i件物品总体积为j的最优解与i-1件物品总体积为j的最优解相同。（此因为体积不够）

   ```C++
   if( j < v[i])
       f[i][j] = f[i - 1][j];
   ```

2.  当前被博爱的总体积大于等于第i件物品的体积，那么又可以分两种选择

   1. 选择第i件物品
   2. 不选第i件物品

   ```C++
   if( j >= v[i])
       f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i]] + w[i]);
   /* 选与不选的判断标准：假设选择第i件物品，则此时背包的最优解变成了求 w[i] + f[i - 1][j - v[i]]的最优解，即：从i-1件物品总体积为j-v[i]的条件下找出
   最优解。（因为选择了第i件物品，所以剩下可选的物品只有i-1件，背包总体积为 j - v[i];
   
   max(f[i - 1][j],f[i - 1][j - v[i]] + w[i]) 的解释：
   	若是：w[i] + f[i - 1][j - v[i]] > f[i - 1][j]； 则说明加入的第 i 件物品整体相对来说，体积相对价值来说较小，价值高。 即性价比高
   	若是：w[i] + f[i - 1][j - v[i]] < f[i - 1][j];  则说明加入的第 i 件物品，体积大，价值还不高，性价比低
   *、
   ```

   

二维dp 01 背包：在总体积为j的情况下从i件物品中找到最优解

```C++
for(int i = 1;i <= n;i ++)
	for(int j = 1;j <= m;j ++)
		if(j < v[i]) f[i][j] = f[i-1][j];
		else f[i][j] = max(f[i - 1][j],f[i - 1][j - v[i]] + w[i]);

/*
	可见 通过二维数组遍历，前面的状态可由后面的状态决定：因为通过循环遍历，i只增不减，所以选过的物品不会重新被选中。  
		即f[i][j] 由 f[i-1][j] 决定，但是f[i][j] 与 f[i-1][j] 所选的物品并不重合，所以又称f[i][j] 与 f[i-1][j] 相互独立
*/
```

**********

## 一维

[大佬详解！！！（一维变换讲得非常非常好！！！)](https://blog.csdn.net/qq_52416556/article/details/124486448?spm=1001.2014.3001.5501)

关于为什么是背包体积倒序遍历而不是顺序遍历：

（1）状态f[j]定义：N 件物品，背包容量j下的最优解。

（2）注意枚举背包容量j必须从m开始。

（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态f[i][j]是由上一轮i - 1的状态得来的，f[i][j]与f[i - 1][j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。

这句话什么意思呢？**（[超级详解的视频解释！！！](https://www.bilibili.com/video/BV19Y411j7uY?p=3&spm_id_from=pageDriver&vd_source=235a1e7b912d1c10826a324e11418122)）**
f[j]从f[j - w]转移过来，那么这里的f[j - w]是指f[i - 1][j - w]还是f[i][j - w]就尤为重要，如果是正序循环，这样的f[j - w]就是f[i][j - w], 因为我们在算f[j]之前，f[j - w]也就是f[i - 1][j - w]就已经算出来了，如果是倒叙循环，就可以完美解决这个问题， 此时的f[j - w]还没计算，是上一层的结果，即f[i - 1][j - w],所以需要倒着写.



```C++
/*
例子一：假设有3件物品，背包的总体积为10
物品       体积      价值
i = 1         4           5
i = 2         5           6
i = 3         6           7
如果 f[0][j] 总共0件物品，所以最大价值为 0， 即 f[0][j] == 0 也是成立的
*/

如果 j 层循环是递增的： 
  for (int i = 1; i <= n; i++) {        // 物品件数	
      for (int j = v[i]; j <= m; j++) {
          f[j] = max(f[j], f[j - v[i]] + w[i]);
      }
  }
  当还未进入循环时(初始状态):
  f[0] = 0;  f[1] = 0;  f[2] = 0;  f[3] = 0;  f[4] = 0;  
  f[5] = 0;  f[6] = 0;  f[7] = 0;  f[8] = 0;  f[9] = 0; f[10] = 0;
  当进入循环 i == 1 时：
  f[4] = max(f[4], f[0] + 5); 即max(0, 5) = 5; 即f[4] = 5;
  f[5] = max(f[5], f[1] + 5); 即max(0, 5) = 5; 即f[5] = 5;
  f[6] = max(f[6], f[2] + 5); 即max(0, 5) = 5; 即f[6] = 5;
  f[7] = max(f[7], f[3] + 5); 即max(0, 5) = 5; 即f[7] = 5;
  重点来了！！！
  f[8] = max(f[8], f[4] + 5); 即max(0, 5 + 5) = 10; 即f[8] = 10;
  这里就已经出错了
  因为此时处于 i == 1 这一层，即物品只有一件，不存在单件物品满足价值为10
  所以已经出错了。
```



**********

## 一维与二维的区别

1. 二维dp数组的空间复杂度为O(N^2)(总体积顺序遍历）,滚动dp数组的空间复杂度为O(N)（总体积逆序遍历）
2. 如果需要得到最佳方案，则需要通过回溯（flashback）的方法。（注意：若使用滚动数组，不能直接利用回溯求解方案）
   - 回溯方法仅限于dp二维数组，因为仅二维数组能够记录之前的状态。如果使用滚动数组，那么只能不断的更新之前的数据，没有记忆功能
3. 如果只需求得最佳方案下对应的最佳值，那么就可以仅使用滚动数组。若是题干要求得到最佳方案且最佳方案对应的最佳解，那么就只能使用dp二维数组