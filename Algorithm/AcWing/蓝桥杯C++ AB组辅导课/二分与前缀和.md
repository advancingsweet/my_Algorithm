

# 知识点

## [1.硬核整数二分视频图解](https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.337.search-card.all.click&vd_source=235a1e7b912d1c10826a324e11418122)

## [2.不需要考虑mid+1、mid-1的二分查找模板博文](https://blog.csdn.net/WJPnb1/article/details/126360962?spm=101.2014.301.5502)



1. y总的整数二分查找需要对界限进行讨论

2. M = (L + R + 1)/2   向上取整， M = (L + R )/2  向下取整。 必须得向上取整

   ​    因为当 L = R -1时，向下取整，M = L = R -1,则循环陷入死循环

3. ![image-20230105152508549](C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230105152508549.png)

3.整数二分跟实数二分的差别？

![image-20230105152832669](C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230105152832669.png)

实数二分不需要考虑第4步，不需要考虑取整的问题  

4.有单调性的一定可以二分，但能二分的，不一定具有单调性



******

# [790. 数的三次方根](https://www.acwing.com/problem/content/792/) (实数二分查找)

## 错误代码：

```C++
#include<iostream>
using namespace std;
int main()
{
    double n,mid;
    cin>>n;
    int l = -100,r=100;   //这里应该是  double l = -100, r = 100;
    while(r-l>1e-8)
    {
         mid = (l+r)/2;
        if(mid*mid*mid>=n) r = mid;     
        else l = mid;
    }
    cout<<l<<endl;
    return 0;
}
/*
错因：
	1.double 赋值给 int ，会将小数点省去！！！ 所以循环所得结果不可能精准到第八位小数，则陷入死循环
	2.输出：cout输入输出的值是整数，而printf输出double值，默认保留6位小数  printf("%lf",l);
*/

```

## 正解：

```c++
#include<iostream>
using namespace std;
int main()
{
	double n;
	cin>>n;
	double l = -100,r = 100;
	while(r-l>1e-8)
	{
		double mid = (l+r)/2;
        if(mid*mid*mid<=n) l = mid;
        else r = mid;
	}
    printf("%lf",l);    //此既可输出l,又可输出r,因为当精确到第八位小数时，l,r的前七位小数已经相同
}
```

******

# [789. 数的范围](https://www.acwing.com/problem/content/791/) （整数二分查找）

## 正解：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 10010;
int val[N],K[N];

int main()
{
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++) scanf("%d",&val[i]);
    for(int i=0;i<k;i++) scanf("%d",&K[i]);
    /*
    输入方式也可以是
    while(k--)
    {
    	int x;
    	cin>>x;
    	--------
    }
    */
   for(int i=0;i<k;i++)                           
    {
        int l = -1,r = n;
        while(l+1!=r)
        {
            int mid = (l+r)/2;
            if(val[mid]>=K[i]) r = mid;
            else l = mid;
        }
        
        if(val[r]==K[i])  //上一层while循环退出，l + 1 =r;
        {
            cout<<r<<" ";
            r = n;
            while(l+1!=r){
                int mid = l+r>>1;
                if(val[mid]<=K[i]) l = mid;
                else r = mid;
            }
            cout<<l<<endl;
        }
        else cout<<"-1 -1"<<endl;
    }
}

/* 
此种整数二分查找，详见  知识点 1.硬核整数二分视频图解
*/
```

[硬核整数二分视频图解](https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.337.search-card.all.click&vd_source=235a1e7b912d1c10826a324e11418122)

*********

# [730. 机器人跳跃问题](https://www.acwing.com/problem/content/732/)

## 正解：

```C++
/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1e5+10;

int n;
int val[N];

bool check(int mid)
{
    for(int i=0;i<n;i++)
    {
        if(2 * mid - val[i] <0) return false;
        else mid = 2 * mid - val[i];
        if( mid >= N) return true;
    }
    return true;
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d",&val[i]);
    
    int l = -1, r = N, mid;
    while(l+1!=r)
    {
         mid = l + r >> 1;
        if(check(mid)) r = mid;   //满足，范围缩小
        else l = mid;       // 不满足，范围扩大
    }
    printf("%d",r);
}
```







***********

# [AcWing 1221. 四平方和](https://www.acwing.com/activity/content/problem/content/1571/)

## 我的代码（暴力求解，ac十分十分勉强强）：

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>

using namespace std;
const int N = 1510;
int n;

int main(){
    
    scanf("%d",&n);
   for(int a=0;a<1000;a++)
    for(int b =a;b<400;b++)                     //所有的数据都是一次一次ac发现出来的，求解并不规范。
        for(int c =b;c<N;c++)
            {
                int m = n - (a*a+b*b+c*c);
                int d = sqrt(m);
                if(m>0&&d*d==m) {
                    printf("%d %d %d %d",a,b,c,d);
                    return 0;
                }
            }
    return 0;
}

```

## y总优化代码（整数二分，优雅！）：

```C++
/*
思路：需要遍历四个数，如果爆搜，那么时间复杂度为：O(n^4),会超时

所以可以利用牺牲空间的方式加快速度：
先用两重循环遍历c,d两个数，并将 c*c+d*d的结果跟c,d记录下来，则这可以利用结构体自定义
数据类型将其记录
然后再利用两重循环遍历a,b两个数，利用 m = n - a*a - b*b; 再将所得m与遍历c,d所求得的值
进行对比，如果相等，则记录其值，如果不相等，则该a,b方案不行
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 2500010;

struct Sum     // 注意区别 typedef struct 结构体名 与  struct 结构体名；  前者完全是一个数据类型，如果调用需要再自定义，而后者则是可以直接使用
{
    int s, c, d;
    bool operator <(const Sum &t)const   //需要对sum[N]元素进行排序，所以需要重载运算符，方便 sort 排序
    {
        // 按照定义顺序进行比价
        if(s != t.s) return s < t.s;    // 如果s不相同，就返回s较小的那一个
   // sort 底层逻辑默认是 < ,如果 s<t.s 为true,那么就仍是小于号；如果 s<t.s为false,那么 this 就不小于 s,则 this 大于 s,所以排列为：s,this
    // 一定一定不能忽视了sort 的底层默认逻辑
        if(c != t.c) return c < t.c;	//如果c不相同，就返回c较小的那一个
        return d < t.d;					// 返回d较小的那一个
    }
}sum[N];

int cnt,n;
int main()
{
    cin>>n;
    for(int c = 0;c*c<=n;c++)
        for(int d = c;d*d + c*c <= n;d++)
                sum[cnt++]={d*d+c*c,c,d};  
    // C++ 中的库函数sort可以自定义排序
    sort(sum,sum+cnt);   // 根据<运算符重载，sum内的数值：根据 s,c,d顺序进行排序，所以满足题目要求
    
    for(int a = 0;a*a <=n;a++)
        for(int b = a; a * a + b * b <= n; b ++ )
        {
            int e = n - a * a - b * b;
            int l = -1,r = cnt;
            while( l+1 !=r)
            {
                 int mid = l + r >> 1;
                if(sum[mid].s>=e) r = mid; 
          // 此二分将 e 元素作为分界点， l 永远小于e, 而 r 用于大于等于e，这一点一定一定得弄清楚，弄清楚边界，然后再根据所需要的进行选择：是r还是l 
                else l = mid ;
            }  
            //整数二分查找仅仅是找到位置，但是该位置的元素并非我查询所需要的
            if(sum[r].s==e)    
            {
                printf("%d %d %d %d",a,b,sum[r].c,sum[r].d);
                return 0;
            }
        }
    return 0;
}
```

**********

# [AcWing 1227. 分巧克力](https://www.acwing.com/activity/content/problem/content/1572/)



********

# 二分查找小总结

## 1.实数二分查找

```C++
// 实数二分查找模板：
double x; cin>>x;
double l = -100, r = 100;    // 数据范围：[-100,100]
while(r-l>1e-6){              //精度根据题目要求进行确定
    double mid = (l+r)/2;      // 因为 l,r均为double，所以这里并非整除，而是正常的实数除法
    if( ) ;                    //根据题干要求再放入条件
    else ;
}
// 此输出的 l,r为对应的值
```

在连续的实数范围内查找：如[10,100]的连续范围内查找某个数。所以查找时数据类型应该定义为 double 类型，而不是 int 类型

## 2.整数二分查找

```C++
// 整数二分查找模板（此模板可以省略对界限的讨论）：
int x; cin>>x;
int l = -1, r = n;	
while(l+1!=r)                      
{
    int mid = l + r >> 1;		   // 永远记住： l <= mid <= r
    if(value[mid]>=x) r = mid;     //最终结果： 取r，则为第一个 >=x 的值的位置。 取 l，则为第一个 <x 的值的位置
    else l = mid;
}
// 此输出的 l,r为对应的位置，并非数值
```

