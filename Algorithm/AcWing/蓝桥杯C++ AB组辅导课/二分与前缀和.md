

# 知识点

## [1.硬核整数二分视频图解](https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.337.search-card.all.click&vd_source=235a1e7b912d1c10826a324e11418122)

## [2.不需要考虑mid+1、mid-1的二分查找模板博文](https://blog.csdn.net/WJPnb1/article/details/126360962?spm=101.2014.301.5502)



1. y总的整数二分查找需要对界限进行讨论

2. M = (L + R + 1)/2   向上取整， M = (L + R )/2  向下取整。 必须得向上取整

   ​    因为当 L = R -1时，向下取整，M = L = R -1,则循环陷入死循环

3. ![image-20230105152508549](C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230105152508549.png)

3.整数二分跟实数二分的差别？

![image-20230105152832669](C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230105152832669.png)

实数二分不需要考虑第4步，不需要考虑取整的问题  

4.有单调性的一定可以二分，但能二分的，不一定具有单调性



******

# [790. 数的三次方根](https://www.acwing.com/problem/content/792/) (实数二分查找)

## 错误代码：

```C++
#include<iostream>
using namespace std;
int main()
{
    double n,mid;
    cin>>n;
    int l = -100,r=100;   //这里应该是  double l = -100, r = 100;
    while(r-l>1e-8)
    {
         mid = (l+r)/2;
        if(mid*mid*mid>=n) r = mid;     
        else l = mid;
    }
    cout<<l<<endl;
    return 0;
}
/*
错因：
	1.double 赋值给 int ，会将小数点省去！！！ 所以循环所得结果不可能精准到第八位小数，则陷入死循环
	2.输出：cout输入输出的值是整数，而printf输出double值，默认保留6位小数  printf("%lf",l);
*/

```

## 正解：

```c++
#include<iostream>
using namespace std;
int main()
{
	double n;
	cin>>n;
	double l = -100,r = 100;
	while(r-l>1e-8)
	{
		double mid = (l+r)/2;
        if(mid*mid*mid<=n) l = mid;
        else r = mid;
	}
    printf("%lf",l);    //此既可输出l,又可输出r,因为当精确到第八位小数时，l,r的前七位小数已经相同
}
```

******

# [789. 数的范围](https://www.acwing.com/problem/content/791/) （整数二分查找）

## 正解：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 10010;
int val[N],K[N];

int main()
{
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++) scanf("%d",&val[i]);
    for(int i=0;i<k;i++) scanf("%d",&K[i]);
    /*
    输入方式也可以是
    while(k--)
    {
    	int x;
    	cin>>x;
    	--------
    }
    */
   for(int i=0;i<k;i++)                           
    {
        int l = -1,r = n;
        while(l+1!=r)
        {
            int mid = (l+r)/2;
            if(val[mid]>=K[i]) r = mid;
            else l = mid;
        }
        
        if(val[r]==K[i])  //上一层while循环退出，l + 1 =r;
        {
            cout<<r<<" ";
            r = n;
            while(l+1!=r){
                int mid = l+r>>1;
                if(val[mid]<=K[i]) l = mid;
                else r = mid;
            }
            cout<<l<<endl;
        }
        else cout<<"-1 -1"<<endl;
    }
}

/* 
此种整数二分查找，详见  知识点 1.硬核整数二分视频图解
*/
```

[硬核整数二分视频图解](https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.337.search-card.all.click&vd_source=235a1e7b912d1c10826a324e11418122)

*********

# [730. 机器人跳跃问题](https://www.acwing.com/problem/content/732/)

## 正解一(整数二分查找 从前往后推）：

```C++
/*
自身问题：题干未读懂，看到题目就犯浑，最基本的规律都没有找着

题解： 
1.根据题干要求可得： 每跳一次：E = 2E - H(K+1);

2.对于二分题目，最主要的是寻找分段条件是什么。
此题，“机器人至少以多少能量值开始游戏”，可知能量值的下界限为0，且只要找到mid这个二段条件，<mid 不满足要求，>= mid 满足要求。但似乎无法确定该能量值的上界限。（不知最大就取0x3f3f3f3f,已试，可取，二分法的时间复杂度为O(logN),速度快)  且由第3点分析可知，能量值上限是 max(H(i));

3.隐藏但必须考虑的条件：由于 每一次能量都是 E(k+1)= 2E(k) - H(K+1) = E(k) + E(k) - H(K+1)    从数学角度上分析，当 E(k) > max(H(i)) = 10e5 时，E + E - H(K+1) 严格单调递增。所以得有 if( mid >= N) return true;  如果没有此语句，那么 int 会被爆栈，程序跑不动。

*/ 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1e5+10;

int n;
int val[N];

bool check(int mid)
{
    for(int i=0;i<n;i++)
    {
        if(2 * mid - val[i] <0) return false;
        else mid = 2 * mid - val[i];
        if( mid >= N) return true;
    }
    return true;
}

int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;i++) scanf("%d",&val[i]);
    
    int l = -1, r = N, mid;
    while(l+1!=r)
    {
         mid = l + r >> 1;
        if(check(mid)) r = mid;   //满足，范围缩小
        else l = mid;       // 不满足，范围扩大
    }
    printf("%d",r);
}
```

## 正解二（贪心算法  从后往前推）：

```C++
/*
根据题目, 我们得到的公式是: E(k+1) = 2E(k)−H(k+1)
贪心思想：先假设到达最后是0能量, 然后往前推: E(k) =(E(k+1) + H(k+1))/2, 将结果储存在res[]数组中.保留计算得到小数, 直到第0位置
判断 res[0] 是否 是一个整数:
	如果是, 即为答案, 输出
	如果不是, 向上取整, 输出

思路理解：
1. H(k+1)>=0,E(k+1)>=0, 所以所取的 E(k)>=0，保证了如果从前往后推，则 E(k+1) = 2E(k)−H(k+1) >= 0;
2. 如果res[0] 为整数，则res[0] 刚好满足机器人能够跳到最后一层，并且能量为0，能量刚好达到最低要求，符合题意：“机器人至少以多少能量值开始游戏”
3. 如果res[0] 为小数，则此小数刚好满足机器人能够跳到最后一层，并且能量为0，虽然能量达到最低要求，但是能量必须得取整数，所以向上取整，记为x。
	设最初能量为x时，机器人跳完最后一层的能量为 E(x)。 而 0 ~ E(x)之间的能量，通过反推，推得最初始能量的范围处于 res[0] ~ x之间，此区间仅 x一个整数满足，所以res[0]为小数时，向上取整并输出即满足题意
*/
#include<iostream>
#include<cstdio>

using namespace std;
const int N 1e5+10;

int h[N],n;
double res[N];

int main(){
    cin>>n;
    for(int i=1; i<=n; i++)  
        scanf("%d", &h[i]);
    for(int i=n-1; i>=0; i--)
        res[i] = (res[i+1] + h[i+1]) / 2;   //
    int x = res[0];
    if(res[0]!=x)  cout<<x+1;
    else cout<<x;
    return 0;
}

```

## 错误代码（贪心算法）：

```C++
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e5+10;
int n,H[N];
double E[N];  // E[N]代表跳完第N个建筑之后所剩下的能量。

int main(){
    // n 没有输入！！！
    for(int i=1;i<=n;i++) scanf("%d",&H[i]);
    
    for(int i = n;i>=1;i++)   // 倒序还是i++ ！！！
        E[i-1] = (E[i] + H[i])/2;
    int x = E[0];
    if(x == E[0]);
    else x += 1;
    cout<<x<<endl; 
}
```



***********

# [AcWing 1221. 四平方和](https://www.acwing.com/activity/content/problem/content/1571/)

## 我的代码（暴力求解，ac十分十分勉强强）：

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>

using namespace std;
const int N = 1510;
int n;

int main(){
    
    scanf("%d",&n);
   for(int a=0;a<1000;a++)
    for(int b =a;b<400;b++)                     //所有的数据都是一次一次ac发现出来的，求解并不规范。
        for(int c =b;c<N;c++)
            {
                int m = n - (a*a+b*b+c*c);
                int d = sqrt(m);
                if(m>0&&d*d==m) {
                    printf("%d %d %d %d",a,b,c,d);
                    return 0;
                }
            }
    return 0;
}

```

## y总优化代码（整数二分，优雅！）：

```C++
/*
思路：需要遍历四个数，如果爆搜，那么时间复杂度为：O(n^4),会超时

所以可以利用牺牲空间的方式加快速度：
先用两重循环遍历c,d两个数，并将 c*c+d*d的结果跟c,d记录下来，则这可以利用结构体自定义
数据类型将其记录
然后再利用两重循环遍历a,b两个数，利用 m = n - a*a - b*b; 再将所得m与遍历c,d所求得的值
进行对比，如果相等，则记录其值，如果不相等，则该a,b方案不行
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 2500010;

struct Sum     // 注意区别 typedef struct 结构体名 与  struct 结构体名；  前者完全是一个数据类型，如果调用需要再自定义，而后者则是可以直接使用
{
    int s, c, d;
    bool operator <(const Sum &t)const   //需要对sum[N]元素进行排序，所以需要重载运算符，方便 sort 排序
    {
        // 按照定义顺序进行比价
        if(s != t.s) return s < t.s;    // 如果s不相同，就返回s较小的那一个
   // sort 底层逻辑默认是 < ,如果 s<t.s 为true,那么就仍是小于号；如果 s<t.s为false,那么 this 就不小于 s,则 this 大于 s,所以排列为：s,this
    // 一定一定不能忽视了sort 的底层默认逻辑
        if(c != t.c) return c < t.c;	//如果c不相同，就返回c较小的那一个
        return d < t.d;					// 返回d较小的那一个
    }
}sum[N];

int cnt,n;
int main()
{
    cin>>n;
    for(int c = 0;c*c<=n;c++)
        for(int d = c;d*d + c*c <= n;d++)
                sum[cnt++]={d*d+c*c,c,d};  
    // C++ 中的库函数sort可以自定义排序
    sort(sum,sum+cnt);   // 根据<运算符重载，sum内的数值：根据 s,c,d顺序进行排序，所以满足题目要求
    
    for(int a = 0;a*a <=n;a++)
        for(int b = a; a * a + b * b <= n; b ++ )
        {
            int e = n - a * a - b * b;
            int l = -1,r = cnt;
            while( l+1 !=r)
            {
                 int mid = l + r >> 1;
                if(sum[mid].s>=e) r = mid; 
          // 此二分将 e 元素作为分界点， l 永远小于e, 而 r 用于大于等于e，这一点一定一定得弄清楚，弄清楚边界，然后再根据所需要的进行选择：是r还是l 
                else l = mid ;
            }  
            //整数二分查找仅仅是找到位置，但是该位置的元素并非我查询所需要的
            if(sum[r].s==e)    
            {
                printf("%d %d %d %d",a,b,sum[r].c,sum[r].d);
                return 0;
            }
        }
    return 0;
}
```

**********

# [AcWing 1227. 分巧克力](https://www.acwing.com/activity/content/problem/content/1572/)

```c++
/*
题干分析： 
1. “输出切出的正方形巧克力最大可能的边长”  可以想着用二分
2. 对于分块类型问题： int num = （h/边长）* （w/边长);   而非用 (h*w) /(边长*边长)。 思路非常巧妙，因为长和宽满足要求时，长*宽也必然满足要求，但长*宽满足要求时，长和宽未必满足要求
3.二分的临界位置： 边长m刚好满足： m减小，可分的数量增加。m增大，可分的数量不够
*/
#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 1e5+10;

int n,k;

struct q{
    int a,b;        // 不知用什么存储，就可以自定义数据类型进行存储
}q[N];

bool check(int mid)
{
    int m =0;
    for(int i=0;i<n;i++)
    {
        int h = q[i].a/mid, w = q[i].b/mid;
        m+=h*w;    
        /*
        代码改进：  
        	m += (q[i].a / mid) * ( q[i].b / mid);
        	if(m>=k) return false;  //只要发现了就可以退出，注意逻辑代表，不能弄混了
        */
    }
    if(m<k) return true;   //即边长mid 太大，得缩小
    return false;  //边长mid 小于等于，得扩大
}

int main()
{
    cin>>n>>k;
    
    for(int i=0;i<n;i++) scanf("%d%d",&q[i].a,&q[i].b);
    
    int l = -1,r = N;
    while(l+1!=r)
    {
        int mid = l + r>>1;   //mid代表边长
        if(check(mid)) r = mid;  //大于最大值,得缩小
        else l = mid;   // 小于等于最大值，得扩大
    }
    cout<<l<<endl;    // 因为是按照 小于等于 进行分类，所以得取l
}
```



********

# 二分查找小总结

## 1.实数二分查找

```C++
// 实数二分查找模板：
double x; cin>>x;
double l = -100, r = 100;    // 数据范围：[-100,100]
while(r-l>1e-6){              //精度根据题目要求进行确定
    double mid = (l+r)/2;      // 因为 l,r均为double，所以这里并非整除，而是正常的实数除法
    if( ) ;                    //根据题干要求再放入条件
    else ;
}
// 此输出的 l,r为对应的值
```

在连续的实数范围内查找：如[10,100]的连续范围内查找某个数。所以查找时数据类型应该定义为 double 类型，而不是 int 类型

## 2.整数二分查找

```C++
// 整数二分查找模板（此模板可以省略对界限的讨论）：
int x; cin>>x;
int l = -1, r = n;	
while(l+1!=r)                      
{
    int mid = l + r >> 1;		   // 永远记住： l <= mid <= r
    if(value[mid]>=x) r = mid;     //最终结果： 取r，则为第一个 >=x 的值的位置。 取 l，则为第一个 <x 的值的位置
    else l = mid;
}
// 此输出的 l,r为对应的位置，并非数值
```

