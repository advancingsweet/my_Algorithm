

# 知识点

## [1.硬核整数二分视频图解](https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.337.search-card.all.click&vd_source=235a1e7b912d1c10826a324e11418122)

## [2.不需要考虑mid+1、mid-1的二分查找模板博文](https://blog.csdn.net/WJPnb1/article/details/126360962?spm=101.2014.301.5502)



1. y总的整数二分查找需要对界限进行讨论

2. M = (L + R + 1)/2   向上取整， M = (L + R )/2  向下取整。 必须得向上取整

   ​    因为当 L = R -1时，向下取整，M = L = R -1,则循环陷入死循环

3. ![image-20230105152508549](C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230105152508549.png)

3.整数二分跟实数二分的差别？

![image-20230105152832669](C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230105152832669.png)

实数二分不需要考虑第4步，不需要考虑取整的问题  

4.有单调性的一定可以二分，但能二分的，不一定具有单调性



******

# [790. 数的三次方根](https://www.acwing.com/problem/content/792/) (实数二分查找)

给定一个浮点数 n，求它的三次方根。

#### 输入格式

共一行，包含一个浮点数 n。

#### 输出格式

共一行，包含一个浮点数，表示问题的解。

注意，结果保留 6 位小数。

#### 数据范围

−100≤n≤100

#### 输入样例：

```
100.0
```

#### 输出样例：

```
10.000
```

## 错误代码：

```C++
#include<iostream>
using namespace std;
int main()
{
    double n,mid;
    cin>>n;
    int l = -100,r=100;   //这里应该是  double l = -100, r = 100;
    while(r-l>1e-8)
    {
         mid = (l+r)/2;
        if(mid*mid*mid>=n) r = mid;     
        else l = mid;
    }
    cout<<l<<endl;
    return 0;
}
/*
错因：
	1.double 赋值给 int ，会将小数点省去！！！ 所以循环所得结果不可能精准到第八位小数，则陷入死循环
	2.输出：cout输入输出的值是整数，而printf输出double值，默认保留6位小数  printf("%lf",l);
*/

```

## 正解：

```c++
#include<iostream>
using namespace std;
int main()
{
	double n;
	cin>>n;
	double l = -100,r = 100;
	while(r-l>1e-8)
	{
		double mid = (l+r)/2;
        if(mid*mid*mid<=n) l = mid;
        else r = mid;
	}
    printf("%lf",l);    //此既可输出l,又可输出r,因为当精确到第八位小数时，l,r的前七位小数已经相同
}
```

******

# [789. 数的范围](https://www.acwing.com/problem/content/791/) （整数二分查找）

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 输入格式

第一行包含整数 n 和 q，表示数组长度和询问个数。

第二行包含 n 个整数（均在 1∼1001∼100 范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

#### 输出格式

共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 数据范围

1≤n≤1000
1≤q≤100
1≤k≤100

#### 输入样例：

```
6 3
1 2 2 3 3 4
3
4
5
```

#### 输出样例：

```
3 4
5 5
-1 -1
```

## 正解：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 10010;
int val[N],K[N];

int main()
{
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++) scanf("%d",&val[i]);
    for(int i=0;i<k;i++) scanf("%d",&K[i]);
    /*
    输入方式也可以是
    while(k--)
    {
    	int x;
    	cin>>x;
    	--------
    }
    */
   for(int i=0;i<k;i++)                           
    {
        int l = -1,r = n;
        while(l+1!=r)
        {
            int mid = (l+r)/2;
            if(val[mid]>=K[i]) r = mid;
            else l = mid;
        }
        
        if(val[r]==K[i])  //上一层while循环退出，l + 1 =r;
        {
            cout<<r<<" ";
            r = n;
            while(l+1!=r){
                int mid = l+r>>1;
                if(val[mid]<=K[i]) l = mid;
                else r = mid;
            }
            cout<<l<<endl;
        }
        else cout<<"-1 -1"<<endl;
    }
}

/* 
此种整数二分查找，详见  知识点 1.硬核整数二分视频图解
*/
```

[硬核整数二分视频图解](https://www.bilibili.com/video/BV1d54y1q7k7/?spm_id_from=333.337.search-card.all.click&vd_source=235a1e7b912d1c10826a324e11418122)

*********

# [730. 机器人跳跃问题](https://www.acwing.com/problem/content/732/)

机器人正在玩一个古老的基于 DOS 的游戏。

游戏中有 N+1 座建筑——从 0 到 N 编号，从左到右排列。

编号为 0 的建筑高度为 0 个单位，编号为 ii 的建筑高度为 H(i)个单位。

起初，机器人在编号为 0 的建筑处。

每一步，它跳到下一个（右边）建筑。

假设机器人在第 k 个建筑，且它现在的能量值是 E，下一步它将跳到第 k+1 个建筑。

如果 H(k+1)>E，那么机器人就失去 H(k+1)−E的能量值，否则它将得到 E−H(k+1) 的能量值。

游戏目标是到达第 N 个建筑，在这个过程中能量值不能为负数个单位。

现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？

#### 输入格式

第一行输入整数 N。

第二行是 N 个空格分隔的整数，H(1),H(2),…,H(N) 代表建筑物的高度。

#### 输出格式

输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。

#### 数据范围

1≤N,H(i)≤$10^5$

#### 输入样例1：

```
5
3 4 3 2 4
```

#### 输出样例1：

```
4
```

#### 输入样例2：

```
3
4 4 4
```

#### 输出样例2：

```
4
```

#### 输入样例3：

```
3
1 6 4
```

#### 输出样例3：

```
3
```

## 正解：

```C++

```







***********

# [AcWing 1221. 四平方和](https://www.acwing.com/activity/content/problem/content/1571/)

四平方和定理，又称为拉格朗日定理：

每个正整数都可以表示为至多 4 个正整数的平方和。

如果把 0 包括进去，就正好可以表示为 4 个数的平方和。

比如：

5=0^2+0^2+1^2+2^2
7=1^2+1^2+1^2+2^2

对于一个给定的正整数，可能存在多种平方和的表示法。

要求你对 4 个数排序：

0≤a≤b≤c≤d

并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。

#### 输入格式

输入一个正整数 4。

#### 输出格式

输出4个非负整数，按从小到大排序，中间用空格分开。

#### 数据范围

0<N<5∗10^6

#### 输入样例：

```
5
```

#### 输出样例：

```
0 0 1 2
```

## 我的代码（暴力求解，ac十分十分勉强强）：

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>

using namespace std;
const int N = 1510;
int n;

int main(){
    
    scanf("%d",&n);
   for(int a=0;a<1000;a++)
    for(int b =a;b<400;b++)                     //所有的数据都是一次一次ac发现出来的，求解并不规范。
        for(int c =b;c<N;c++)
            {
                int m = n - (a*a+b*b+c*c);
                int d = sqrt(m);
                if(m>0&&d*d==m) {
                    printf("%d %d %d %d",a,b,c,d);
                    return 0;
                }
            }
    return 0;
}

```

## y总优化代码（整数二分，优雅！）：

```C++
/*
思路：需要遍历四个数，如果爆搜，那么时间复杂度为：O(n^4),会超时

所以可以利用牺牲空间的方式加快速度：
先用两重循环遍历c,d两个数，并将 c*c+d*d的结果跟c,d记录下来，则这可以利用结构体自定义
数据类型将其记录
然后再利用两重循环遍历a,b两个数，利用 m = n - a*a - b*b; 再将所得m与遍历c,d所求得的值
进行对比，如果相等，则记录其值，如果不相等，则该a,b方案不行
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 2500010;

struct Sum     // 注意区别 typedef struct 结构体名 与  struct 结构体名；  前者完全是一个数据类型，如果调用需要再自定义，而后者则是可以直接使用
{
    int s, c, d;
    bool operator <(const Sum &t)const   //需要对sum[N]元素进行排序，所以需要重载运算符，方便 sort 排序
    {
        // 按照定义顺序进行比价
        if(s != t.s) return s < t.s;    // 如果s不相同，就返回s较小的那一个
   // sort 底层逻辑默认是 < ,如果 s<t.s 为true,那么就仍是小于号；如果 s<t.s为false,那么 this 就不小于 s,则 this 大于 s,所以排列为：s,this
    // 一定一定不能忽视了sort 的底层默认逻辑
        if(c != t.c) return c < t.c;	//如果c不相同，就返回c较小的那一个
        return d < t.d;					// 返回d较小的那一个
    }
}sum[N];

int cnt,n;
int main()
{
    cin>>n;
    for(int c = 0;c*c<=n;c++)
        for(int d = c;d*d + c*c <= n;d++)
                sum[cnt++]={d*d+c*c,c,d};  
    // C++ 中的库函数sort可以自定义排序
    sort(sum,sum+cnt);   // 根据<运算符重载，sum内的数值：根据 s,c,d顺序进行排序，所以满足题目要求
    
    for(int a = 0;a*a <=n;a++)
        for(int b = a; a * a + b * b <= n; b ++ )
        {
            int e = n - a * a - b * b;
            int l = -1,r = cnt;
            while( l+1 !=r)
            {
                 int mid = l + r >> 1;
                if(sum[mid].s>=e) r = mid; 
          // 此二分将 e 元素作为分界点， l 永远小于e, 而 r 用于大于等于e，这一点一定一定得弄清楚，弄清楚边界，然后再根据所需要的进行选择：是r还是l 
                else l = mid ;
            }  
            //整数二分查找仅仅是找到位置，但是该位置的元素并非我查询所需要的
            if(sum[r].s==e)    
            {
                printf("%d %d %d %d",a,b,sum[r].c,sum[r].d);
                return 0;
            }
        }
    return 0;
}
```

**********

# [AcWing 1227. 分巧克力](https://www.acwing.com/activity/content/problem/content/1572/)



********

# 二分查找小总结

## 1.实数二分查找

```C++
// 实数二分查找模板：
double x; cin>>x;
double l = -100, r = 100;    // 数据范围：[-100,100]
while(r-l>1e-6){              //精度根据题目要求进行确定
    double mid = (l+r)/2;      // 因为 l,r均为double，所以这里并非整除，而是正常的实数除法
    if( ) ;                    //根据题干要求再放入条件
    else ;
}
// 此输出的 l,r为对应的值
```

在连续的实数范围内查找：如[10,100]的连续范围内查找某个数。所以查找时数据类型应该定义为 double 类型，而不是 int 类型

## 2.整数二分查找

```C++
// 整数二分查找模板（此模板可以省略对界限的讨论）：
int x; cin>>x;
int l = -1, r = n;	
while(l+1!=r)                      
{
    int mid = l + r >> 1;		   // 永远记住： l <= mid <= r
    if(value[mid]>=x) r = mid;     //最终结果： 取r，则为第一个 >=x 的值的位置。 取 l，则为第一个 <x 的值的位置
    else l = mid;
}
// 此输出的 l,r为对应的位置，并非数值
```

