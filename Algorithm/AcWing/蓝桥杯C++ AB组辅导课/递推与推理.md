# [93. 递归实现组合型枚举](https://www.acwing.com/problem/content/description/95/)

从 1∼n 这 n个整数中随机选出 m 个，输出所有可能的选择方案。

#### 输入格式

两个整数 n,m ,在同一行用空格隔开。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 11 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

#### 数据范围

n>0 ,
0≤m≤n ,
n+(n−m)≤25

#### 输入样例：

```
5 3
```

#### 输出样例：

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
```

**思考题**：如果要求使用非递归方法，该怎么做呢？

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N =18;   //此题n的数据范围：只要所取n使得存在m满足n+(n−m)≤25即可

int n,m;
int way[N];  //对于排列、组合等问题，利用数组保存结果并进行输出

void dfs(int u,int start)
{
    //剪枝优化；当所供选择的元素个数不满足要求时，直接退出   u-1 + n-start +1<m
    if(u+n-start<m) return;  //也可不加，当start>n时，递归函数自动返回上一级。依此类推
    //确定边界
    if(u==m+1){ //确定第u个位置，则已确定的位置为u-1个
        for(int i=1;i<=m;i++) printf("%d ",way[i]);
        puts("");
        return;
    }
    for(int i =start;i<=n;i++){
        way[u] = i;    //u 代表在第u个位置进行选择
        dfs(u+1,i+1);  //不是start+1; 假设当第一次传进来的start为1时，经过三次递归，该层再进行递归，则应该时从5开始，而不是start+1 = 2开始。
        way[u] = 0;  //恢复状态。
    }
}

int main()
{
    scanf("%d%d",&n,&m);
    dfs(1,1);
    return 0;
}
```

# [1209.带分数](https://www.acwing.com/problem/content/1211/)

100可以表示为带分数的形式：100=3+69258/714

还可以表示为：100=82+3546/197

注意特征：带分数中，数字 1∼9分别出现且只出现一次（不包含 0）。

类似这样的带分数，100 有 11 种表示法。

#### 输入格式

一个正整数。

#### 输出格式

输出输入数字用数码 1∼9不重复不遗漏地组成带分数表示的全部种数。

#### 数据范围

1≤N<106 (10的6次方)

#### 输入样例1：

```
100
```

#### 输出样例1：

```
11
```

#### 输入样例2：

```
105
```

#### 输出样例2：

```
6
```







## 题目理解：

1. 未特殊说明，题干中给出的 “/” 为实数的除法运算，并非整除

## 暴力枚举：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N =20;

int ways[N],ans;
bool st[N]; 
double a,b,c,n;

void check()
{
    //边界
    for(int i=1;i<=9;i++)
    {
        if(!st[i]) return;
    }
    for(int i=1;i<8;i++)    //i,j,k代表个数
    {  
        for(int j =1;j<8;j++)
        {
            //错误：for(int k =9-i-j;k<8;k++)  //知道i+j+k =9;所以无需将k表达出来
            //错因：i+j>=9时，也满足此条件进行循环
           if(i+j<9) {
                a = b =c =0;   //必须开头重置为0。因为a,b,c满足不了if条件，无法被重置
                int count=0;
                while(count!=i)
                    a = a*10 + ways[++count];
                while(count!=i+j)
                    b = b*10 + ways[++count];
                while(count!=9)
                    c= c*10 +ways[++count];
                if(n==a+b*1.0/c) ans++;
                /*
                if(n*c == a*c +b) {
                    ans++;
                    a=b=c=0; 
                }
                */
            }
        }
        
    }
    return ;
}

void dfs(int u)     //1~9全排列
{
    /*
    错误:
    if(u==10) return;
    check();
    
    错因：仅当排列了9位数才需要进行check(),而不是排列了9位数就退出程序。没有排列9位数，每排一次就进行一次无用check();
    
    */
    
    if(u==10){
        check();
        return;
    }
    for(int i=1;i<=9;i++)
    {
        if(!st[i]){
            st[i] = true;
            ways[u] = i;
            dfs(u+1);
            st[i] = false;
            ways[u] = 0;
        }
    }
}

int main()
{
    
    scanf("%lf",&n);
    
    dfs(1);  //当前遍历的位数
    
    cout<<ans<<endl;
    
    return 0;
    
}
```

## 优化代码：

```c++
/*
思路：对整体进行化简：b = n*c - a*c 
遍历 a,c的所有选择，然后check(b),a,b,c是否不重复且利用了1~9
遍历一次a,就得遍历一次c
每次遍历，都已选与不选两种选择（对应状态恢复，递归的显著特征）
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N =10;

bool st[N],used[N];
int n,ans;

bool check(int a,int c)
{
    //注意数据范围！
    long long b =  n*(long long)c -  a*c;
    //确定边界
    if(!a||!b||!c) return false;
  //避免dfs_a,dfs_c中同时放入 st[i] = true/false,used[i] = true/false;
    memcpy(used,st,sizeof(st));  
    while(b){
        int x = b%10;
        b/=10;
        if(!x||used[x]) return false;  //尽管a,c中不可能存在0，但是n*c -  a*c所得数中不一定没有0
       //修改前： if(used[x]) return false;  //被使用过
        used[x] = true;       //将b中的数字记录到used中
    }
    //最后再对used数组进行检查，是否有没有利用到的数字
    for(int i=1;i<10;i++)
        if(!used[i]) return false;   //如果有没有利用上的，则不满足情况
    return true;
}
void dfs_c(int a,int c)
{
    //确定边界(剪枝)
   // 编译错误代码：if(a>=n||c>=n) return;   a肯定不能大于n,但是b,c都是可以大于n的
    if(check(a,c)) ans++;
    
    for(int i=1;i<=9;i++)
    {
        if(!st[i]){
            st[i] = true;
            dfs_c(a,c*10+i);
            st[i] = false;
        }
    }
}
void dfs_a(int a)
{
    if(a>=n) return;
    //因为该递归是带循环的递归（递归次数有限，所以无需边界条件也可）
    if(a) dfs_c(a,0);  //遍历一次a（此时a更新一次),所以c就得从头开始遍历
    
    // a = 639 第一次：1~9选6；第二次：1~5，7~9选3；第三次：1,2,3,4,5,7,8,9选9；
    
    for(int i=1;i<=9;i++)
    {
        if(!st[i]){
            st[i] = true;
            dfs_a(a*10+i);
            st[i] = false;
        }
    }
}
int main()
{
    scanf("%d",&n);
    dfs_a(0);  //传的数值为a
    cout<<ans<<endl;
    return 0;
}
```









