# 分组背包问题

[9. 分组背包问题](https://www.acwing.com/problem/content/9/)

## 一、分组背包详解

```C++
/*
	分组背包对比01背包：	
 0-1背包： 有k钟物品，有一个容量为m的背包，每种物品只能选一个，求最大价值
分组背包： 有k组物品，有一个容量为m的背包，每组物品当中只能选一个，求最大价值


0-1背包： f[j] = max( f[j], f[j-v[i]] + w[i])
分组背包：f[j] = max( f[j], f[j-v[第i组当中的一个]] + w[第i组当中的一个]).

所以在01背包的基础里面，再加上一层循环，遍历第i组中的物品。
*/


//********************************************************  一维滚动数组
// 0 - 1 背包
for(int i = 1;i <= n;i ++)
    for(int j = m; j >= v[i];j --)
        dp[j] = max( dp[j],dp[j-v[i]] + w[i]);

//分组背包
for(int k = 1; k <= n;k ++)
    for(int j = m; j >= 1; j --)
        for(int i = 1;i <= s[k];i ++)
            dp[j] = max( dp[j],dp[j-v[k][i]] + w[k][i]);

//********************************************************  二维动态规划数组
//0 - 1 背包
for(int i = 1;i <= n;i ++)     // dp[i][j] : 前i件物品与总体积情况下的最优解
    for(int j = 1;j <= m;j ++)
        if(j < v[i]) dp[i][j] = dp[i-1][j];
		else dp[i][j] = max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);

//分组背包
for(int k = 1;k <= n;k ++)     // dp[k][j] : 前k个背包与总体积j情况下的最优解
    for(int j = 1; j <= m; j ++)  
    {
        dp[k][j] = dp[k-1][j]; // 选与不选均只有一次，所以应该提到遍历第k组的物品循环之外。
        for(int i = 1;i <= s[k]; i ++)
            dp[k][j] = max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]);  // 确定遍历的前提：体积是不变的！
        /*
        	由于每件物品只能选择一次，所以为防止在（k,j) 组合下装入多个物品，则需要将当前状态进行替换。
 对于：max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]) ：
 		
 		dp[k-1][j-v[k][i]] + w[k][j] : 当前（k,i)物品与（k-1,j-v[k][i]+w[k][i])情况的最优解
 		max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]) ：
                情况一：
                	dp[k][j] ：还没有选择物品，则代表dp[k-1][j]。
			   情况二：
                    dp[k][j] : 若已经选过一次物品，则代表更新后的dp[k][j];
                    则：max(式)比较是 （k,i)物品与（k-1,j-v[k][i])情况的最优解  同 （k,i+m)物品与（k-1,j-v[k][i+m]+w[k][i])情况的最优解  谁更优
                综上：此永远确保了(k,j)情况下，要么没有进行选择，要么仅选择了一种。
        */
        
    }
```



## 二、典型错误

1. 先决策第k个背包中的第i个物品，再遍历体积

   - 假设对第i组里的物品k，把所有体积遍历了一次，然后选择了这件物品，这个时候f[i][j]已经包含了第i组中一个物品，也就是k；接下来还是这一组，第k+1个物品，又枚举所有体积，并且你也选择了这一个物品，即f[i][j]=max(f[i-1][j],f[i-1][j-v[i][k+1]]+w[i][k+1])中后者更大，更新之后f变成了后者。 这就意味着在第i组中同时选择了k和k+1两个物品。而如果固定体积，遍历物品，就不会有这个问题，因为每次遍历都只能选中一件物品；这本质上还是在优化成一维数组之后数组的更新过程中需要注意的问题，就像y总说的要保证等价。

   - 再解释：当想不通时，牢记下方语句，

     ```C++
     dp[k][j]  = max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][i]);
     ```

     

   

```C++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;


const int N = 110;

int dp[N][N];
int s[N],v[N][N],w[N][N];
int n,m;

int main()
{
    cin>>n>>m;
    
    for(int i = 1;i <= n; i++)   // 数据读入
    {
        scanf("%d",&s[i]);
        for(int j = 1;j <= s[i];j ++)
            scanf("%d%d",&v[i][j],&w[i][j]);
    }
    
    // for(int k = 1;k <= n; k++)
    //     for(int j = 1;j <= m;j ++)
    //         for(int i = 1; i <= s[k];i ++)
    //             if(j < v[k][i]) dp[k][j] = dp[k-1][j];
    //             else dp[k][j] = max( dp[k-1][j],dp[k-1][j-v[k][i]] + w[k][i]);
    
     for(int k = 1;k <= n; k++)  // k 个组合
        for(int j = 1;j <= m;j ++)
        {
            dp[k][j] = dp[k-1][j]; // 首先我不选择，通过对比再进行决定是否选择。 不选择仅有一次，
            for(int i = 1; i <= s[k];i ++)
                if(j >= v[k][i]) dp[k][j] = max( dp[k][j],dp[k-1][j-v[k][i]] + w[k][i]); 
            // 一定得是dp[k][j],不能是dp[k-1][j]。如果时dp[k-1][j] 
            // 解释：当同一体积有多个性价比较高的物品可装时，则应该前后相互比较，确保了该组中物品仅装入了一件，而没有被重复装入
        }
    
    cout<<dp[n][m]<<endl;
    return 0;
}
```



# 思路：

1. 将整个组视为一个完整的"物件"，则可将其理解其0-1背包，所以先遍历”物件“，再遍历体积
2. 遍历第k个“物件”时，可以先不选，然后再遍历“物件”中的物件。（因为选与不选均只有一次，所以不选应该放在第二、三层循环之间。）
3. 

```C++
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>

using namespace std;


const int N = 110;

int dp[N][N];
int s[N],v[N][N],w[N][N];
int n,m;

int main()
{
    cin>>n>>m;
    
    for(int i = 1;i <= n; i++)   // 数据读入
    {
        scanf("%d",&s[i]);
        for(int j = 1;j <= s[i];j ++)
            scanf("%d%d",&v[i][j],&w[i][j]);
    }
     for(int k = 1;k <= n; k++)  // k 个组合
        for(int j = 1;j <= m;j ++)
        {
            dp[k][j] = dp[k-1][j]; // 首先我不选择，通过对比再进行决定是否选择。 不选择仅有一次，
            for(int i = 1; i <= s[k];i ++)
                if(j >= v[k][i]) dp[k][j] = max( dp[k][j],dp[k-1][j-v[k][i]] + w[k][i]);
        }
    
    cout<<dp[n][m]<<endl;
    
    
    return 0;
}
```

