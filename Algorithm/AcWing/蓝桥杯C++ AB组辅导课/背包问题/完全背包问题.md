# 完全背包问题

[【超精细!】动态规划---完全背包问题全面解读！！](https://www.bilibili.com/video/BV1ta411e7jt/?spm_id_from=333.337.search-card.all.click&vd_source=235a1e7b912d1c10826a324e11418122)    （详细讲解了 完全背包的公式推导以及 完全背包与01背包公式的区别）

```C++
/*
    与 0-1 背包相比，
*/
#include<cstring>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<iostream>

using namespace std;

const int N = 1010;

int dp[N][N];
int m,n;

int main()
{
    
    cin>>n>>m;
    
    int x,y;
    
    for(int i = 1;i <= n;i++)
     {
         scanf("%d%d",&x,&y);
         for(int j = 1;j <= m;j ++)
            if(j < x) dp[i][j] = dp[i-1][j];
            else dp[i][j] = max(dp[i-1][j],dp[i][j-x] + y);  
        	/* 0-1 背包：dp[i][j] = max(dp[i-1][j],dp[i-1][j-x]+y) 因为物品数量无限，所以dp[i][j] 由dp[i][j-x] 决定 。
        	含义： dp[i][j] = max(max(dp[i][j - k*v]] + k * w),dp[i-1][j]); ( 0 <= k <= j/v ) 从中选取一个k，使其性价比高过dp[i-1][j]
        	*/
     }
     
     cout<<dp[n][m]<<endl;
     return 0;
    
}
```

## 状态转移公式推导

![image-20230314172306199](C:\Users\Hongwei Tang\AppData\Roaming\Typora\typora-user-images\image-20230314172306199.png)