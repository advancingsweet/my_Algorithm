# 多重背包

[\4. 多重背包问题 I](https://www.acwing.com/problem/content/4/)

若利用朴素方法直接将其转化成0-1背包问题

1. ​	利用滑动数组，不需要记录物品一共有多少件数
2.    开一个记录件数的k，k = n * (s[i])求和；

**********

## 1.一维滑动数组

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 110;  // 总体积不会变

int dp[N];
int n,m,v,w,s;

int main()
{
    cin>>n>>m;
    
    for(int i = 1;i <= n; i ++)
    {
        scanf("%d%d%d",&v,&w,&s);      //因为不知道具体次数，所以多重背包暴力求解时，最好选择用一维滑动数组。
        while(s --){
            for(int j = m; j >= v;j --)
                dp[j] = max(dp[j],dp[j-v] + w);
        }
    }
    
    cout<<dp[m]<<endl;
    return 0;
}


```

**************

## 2.利用变量记录总件数

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>

using namespace std;
const int N = 110,M = 10010;

int n,m,k;
int dp[M][N],f[N];
int x,y,s;

int main()
{
    cin>>n>>m;
    for(int i = 1;i <= n;i ++)
    {
        cin>>x>>y>>s;
        while(s--)    // 得考虑件数
        {
            k++;  // 利用k计算数组
            for(int j = 1;j <=m;j ++)
                if(j < x) dp[k][j] = dp[k - 1][j];
                else dp[k][j] = max(dp[k-1][j],dp[k-1][j-x] + y);
        }
    }
    
    cout<<dp[k][m]<<endl;
    
    return 0;
}
```

******************

3.因为没有弄清楚件数的记录而发生的明显错误

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 1010;

int n,m,x,y,s;

int dp[N][N];

int main()
{
    cin>>n>>m;
    
    for(int i = 1;i <= n;i ++)    // 遍历次数并非仅有n次，所以使用一维滑动数组最好
    {
        scanf("%d%d%d",&x,&y,&s);
        while(s--){
            for(int j = 1;j <= m;j ++)
                if(j < x) dp[i][j] = dp[i-1][j];
                else dp[i][j] = max(dp[i-1][j],dp[i-1][j - x] + y);
        }
    }
    cout<<dp[n][m]<<endl;
    return 0;
    
}
```


输出

```
8
```

标准答案

```
10
```