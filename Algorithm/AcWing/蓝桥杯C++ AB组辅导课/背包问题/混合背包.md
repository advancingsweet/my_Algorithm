# 混合背包

## [7. 混合背包问题](https://www.acwing.com/problem/content/7/)

## 正解

```C++
/*
    思路：全部转换成01背包处理
    1. 01背包、完全背包直接存储
    2.  多重背包单独处理
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int M = 10100;

int v,w,s,k;
int n,m;
int dp[M];
int tempv[M],tempw[M];

int main()
{
    cin>>n>>m;
    
    for(int i = 1;i <= n;i ++)
    {
        scanf("%d%d%d",&v,&w,&s);
        if(s == -1){    // 01背包
            k ++;
            tempv[k] = v;
            tempw[k] = w;
        }
        else {          // 多重背包 + 完全背包
            if(!s) s = m / v;     // 借助背包总体积将完全背包转化成多重背包
            for(int j = 1; j <= s;j <<= 1)
            {
                k ++;
                tempv[k] = j * v;
                tempw[k] = j * w;
                s -= j;
            }
            if(s){
                k ++;
                tempv[k] = s * v;
                tempw[k] = s * w;
            }
        }
    }
    for(int i = 1; i <= k;i ++)
        for(int j = m;j >= tempv[i];j --)
            dp[j] = max(dp[j],dp[j-tempv[i]] + tempw[i]);
    
    cout<<dp[m]<<endl;
    return 0;
}
```



## 典型错例

将 01 背包和多重背包（二进制优化）处理一次，再将完全背包处理一次。 每种物品都不会多选，但是所装物品的总体积会超过背包的总体积

```C++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>

using namespace std;

const int N = 14000,M = 1010;

int v,w,s,k;
int n,m;
int dp[M];
int tempv[M],tempw[M];

int main()
{
    cin>>n>>m;
    
    for(int i = 1;i <= n;i ++)
    {
        scanf("%d%d%d",&v,&w,&s);
        if(s == -1){    // 01背包
            k ++;
            tempv[k] = v;
            tempw[k] = w;
        }
        else if(!s){   // 完全背包
            for(int j = 1;j <= m;j ++)
                dp[j] = max(dp[j],dp[j-v] + w);
        }
        else {    // 多重背包
            for(int j = 1; j <= s;j <<= 1)
            {
                k ++;
                tempv[k] = j * v;
                tempw[k] = j * w;
                s -= j;
            }
            if(s){
                k ++;
                tempv[k] = s * v;
                tempw[k] = s * w;
            }
        }
    }
    
    for(int i = 1; i <= k;i ++)
        for(int j = m;j >= tempv[i];j --)
            dp[j] = max(dp[j],dp[j-tempv[i]] + tempw[i]);
    
    cout<<dp[m]<<endl;
    
    return 0;
}
```

