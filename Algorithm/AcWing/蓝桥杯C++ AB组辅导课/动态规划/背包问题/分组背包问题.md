# 分组背包问题

[9. 分组背包问题](https://www.acwing.com/problem/content/9/)

## 一、分组背包详解

```C++
/*
	分组背包对比01背包：	
 0-1背包： 有k钟物品，有一个容量为m的背包，每种物品只能选一个，求最大价值
分组背包： 有k组物品，有一个容量为m的背包，每组物品当中只能选一个，求最大价值


0-1背包： f[j] = max( f[j], f[j-v[i]] + w[i])
分组背包：f[j] = max( f[j], f[j-v[第i组当中的一个]] + w[第i组当中的一个]).

所以在01背包的基础里面，再加上一层循环，遍历第i组中的物品。
*/


//********************************************************  一维滚动数组
// 0 - 1 背包
for(int i = 1;i <= n;i ++)
    for(int j = m; j >= v[i];j --)
        dp[j] = max( dp[j],dp[j-v[i]] + w[i]);  // 因为j的范围是从 m~v[k][i]. 所以不需要进行特判

//分组背包
for(int k = 1; k <= n;k ++)
    for(int j = m; j >= 1; j --)   
        for(int i = 1;i <= s[k];i ++)
            if(j >= v[k][i]) dp[j] = max( dp[j],dp[j-v[k][i]] + w[k][i]); // 因为j的范围是从 m~1, 不是从 m~v[k][i]. 所以得需要进行特判

//********************************************************  二维动态规划数组
//0 - 1 背包
for(int i = 1;i <= n;i ++)     // dp[i][j] : 前i件物品与总体积情况下的最优解
    for(int j = 1;j <= m;j ++)
        if(j < v[i]) dp[i][j] = dp[i-1][j];
		else dp[i][j] = max(dp[i-1][j],dp[i-1][j-v[i]]+w[i]);

//分组背包
for(int k = 1;k <= n;k ++)     // dp[k][j] : 前k个背包与总体积j情况下的最优解
    for(int j = 1; j <= m; j ++)  
    {
        dp[k][j] = dp[k-1][j]; // 选与不选均只有一次，所以应该提到遍历第k组的物品循环之外。
        for(int i = 1;i <= s[k]; i ++)
            if(j >= v[k][i]) dp[k][j] = max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]);  // 确定遍历的前提：体积是不变的！
        /*
         对max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]) 的解释 ：
            dp[k-1][j-v[k][i]] + w[k][j] : 当前（k,i)物品与（k-1,j-v[k][i]+w[k][i])情况的最优解
            max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]) ：
                 情况一：
                      dp[k][j] ：还没有选择物品，则代表dp[k-1][j]。
                 情况二：
                     dp[k][j] : 若已经选过一次物品，则代表更新后的dp[k][j];
                     则：max(式)比较是 （k,i)物品与（k-1,j-v[k][i])情况的最优解  同 （k,i+m)物品与（k-1,j-v[k][i+m]+w[k][i])情况的最优解  谁更优
          综上：此永远确保了(k,j)情况下，要么没有进行选择，要么仅选择了一种。
        */
    }
```



## 二、3种典型错误

```C++
// 经典错误中的经典错误 
for(int k = 1;k <= n; k++)
         for(int j = 1;j <= m;j ++)
            for(int i = 1; i <= s[k];i ++)
                 if(j < v[k][i]) dp[k][j] = dp[k-1][j];
                else dp[k][j] = max( dp[k-1][j],dp[k-1][j-v[k][i]] + w[k][i]);
```

1. **先决策第k个背包中的第i个物品，再遍历体积**

   - 假设对第i组里的物品k，把所有体积遍历了一次，然后选择了这件物品，这个时候f[i][j]已经包含了第i组中一个物品，也就是k；接下来还是这一组，第k+1个物品，又枚举所有体积，并且你也选择了这一个物品，即f[i][j]=max(f[i-1][j],f[i-1][j-v[i][k+1]]+w[i][k+1])中后者更大，更新之后f变成了后者。 这就意味着在第i组中同时选择了k和k+1两个物品。而如果固定体积，遍历物品，就不会有这个问题，因为每次遍历都只能选中一件物品；这本质上还是在优化成一维数组之后数组的更新过程中需要注意的问题，就像y总说的要保证等价。

   - 再解释：当想不通时，牢记下方语句，

     ```C++
     dp[k][j]  = max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][i]);
     ```

1. **一个分组中选与不选只进行一次（对于二维动态规划数组）**

   - 不选：就只进行一次，**所以不需要放入第k组物品循环中**
   - 选：通过不断更新保证其只被选取一次
   
1. **更新过程中**

   ```C++
   dp[k][j] = max( dp[k][j],dp[k-1][j-v[k][i]] + w[k][i]); 
   // 并非 dp[k][j] = max(dp[k-1][j],dp[k-1][j-v[k][i]] + w[k][i]);
   对max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]) 的解释 ：
              1. dp[k-1][j-v[k][i]] + w[k][j] : 当前（k,i)物品与（k-1,j-v[k][i]+w[k][i])情况的最优解
              2. max(dp[k][j],dp[k-1][j-v[k][i]] + w[k][j]) ：
                    情况一：
                         dp[k][j] ：还没有选择物品，则代表dp[k-1][j]。
                    情况二：
                        dp[k][j] : 若已经选过一次物品，则代表更新后的dp[k][j];
                        则：max(式)比较是 （k,i)物品与（k-1,j-v[k][i])情况的最优解  同 （k,i+m)物品与（k-1,j-v[k][i+m]+w[k][i])情况的最优解  谁更优
             综上：此永远确保了(k,j)情况下，要么没有进行选择，要么仅选择了一种。
   
   ```
